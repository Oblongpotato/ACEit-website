<h3>What do you mean by an operating system? What are its basic functions?</h3>
<p>Operating System (OS) is basically a software program that manages and handles all resources of a computer such as
    hardware and software. The first OS was introduced in the early 1950s known as GMOs. An OS is responsible for
    managing, handling, and coordinating overall activities and sharing of computer resources. It acts as an
    intermediary among users of computer and computer hardware.&nbsp;</p>
<p><strong>Functions of OS:</strong><br>There are many functions of the OS. Some of the important functions of OS are
    given below:</p>
<ul>
    <li>Memory and Processor Management</li>
    <li>Providing user interface to users</li>
    <li>File Management and Device Management</li>
    <li>Scheduling of resources and jobs</li>
    <li>Error Detection</li>
    <li>Security</li>
</ul>
<h2>Basic OS Interview Questions</h2>
<section class="ibpage-article-header" id="operating-system-importance">
    <h3>1. Why is the operating system important? </h3>
    <article class="ibpage-article">
        <p>OS is the most essential and vital part of a computer without which it is considered useless. It enables an
            interface or acts like a link for interaction between computer software that is installed on OS and users.
            It also helps to communicate with hardware and also maintains balance among hardware and CPU. It also
            provides services to users and a platform for programs to run on. It performs all common tasks applications
            require.&nbsp;</p>
    </article>
</section>
<section class="ibpage-article-header" id="understanding-os">
    <h3>2. What's the main purpose of an OS? What are the different types of OS?</h3>
    <article class="ibpage-article">
        <p>The main purpose of an OS is to execute user programs and make it easier for users to understand and interact
            with computers as well as run applications. It is specially designed to ensure that the computer system
            performs better by managing all computational activities. It also manages computer memory, processes, and
            operation of all hardware and software.<br><br><strong>Types of OS:</strong></p>
        <ul>
            <li>Batched OS (Example: Payroll System, Transactions Process, etc.)</li>
            <li>Multi-Programmed OS (Example: Windows O/S, UNIX O/S, etc.)</li>
            <li>Timesharing OS (Example: Multics, etc.)</li>
            <li>Distributed OS (LOCUS, etc.)</li>
            <li>Real-Time OS (PSOS, VRTX, etc.)</li>
        </ul>
    </article>
</section>
<section class="ibpage-article-header" id="multiprocessor-system">
    <h3>3. What are the benefits of a multiprocessor system?</h3>
    <article class="ibpage-article">
        <p>A Multiprocessor system is a type of system that includes two or more CPUs. It involves the processing of
            different computer programs at the same time mostly by a computer system with two or more CPUs that are
            sharing single memory.&nbsp;<br><br><strong><u>Benefits:</u></strong></p>
        <ul>
            <li>Such systems are used widely nowadays to improve performance in systems that are running multiple
                programs concurrently.&nbsp;</li>
            <li>By increasing the number of processors, a greater number of tasks can be completed in unit time.&nbsp;
            </li>
            <li>One also gets a considerable increase in throughput and is cost-effective also as all processors share
                the same resources.</li>
            <li>It simply improves the reliability of the computer system.</li>
        </ul>
    </article>
</section>
<!-- <div class="ibpage__download-container">
    <div class="ibpage__download-banner">
        <div class="ibpage__download-text">
            <i class="icon-bell"></i>
            <span>
                You can download a PDF version of Operating System Interview Questions.
            </span>
        </div>
        <div class="ibpage__download-action">

            <a class="ibpage__downloadable-a ibpage__downloadable download-pdf" data-source="in_content">
                <span><img class="ibpage__downloadable-img" width="24" height="24"
                        data-src="https://assets.interviewbit.com/assets/svg/download_icon-cd2d5b54bc600ee83352693330804e7d9324dddf41fc105cd5e3176e92f3cd36.svg.gz"
                        src="https://assets.interviewbit.com/assets/svg/download_icon-cd2d5b54bc600ee83352693330804e7d9324dddf41fc105cd5e3176e92f3cd36.svg.gz"></span>
                <span class=" text">Download PDF</span>
            </a>

            <a class="auth-trigger gtm-track-element hidden ibpage__downloadable ibpage__downloadable-a enforce-signin "
                onclick="window.trackGaEvent('onboarding', 'signin-cta-clicked', 'Download PDF')" style=""
                href="javascript:void(0)" data-action="flow-trigger" data-target="auth" data-mode="login"
                data-gtm-element="login" data-gtm-allowed-actions="click hover" data-source="in_content">

                <span><img class="lazy-elem ibpage__downloadable-img" width="24" height="24"
                        data-src="https://assets.interviewbit.com/assets/svg/download_icon-cd2d5b54bc600ee83352693330804e7d9324dddf41fc105cd5e3176e92f3cd36.svg.gz"></span>
                <span class=" text">Download PDF</span>

            </a>

            <a id="auto-download-modal-trigger" class="modal-trigger hidden gtm-track-element"
                data-gtm-allowed-actions="click" data-gtm-type="button" data-gtm-parent="auto-download-modal"
                data-action="modal-open" data-target="auto-download-modal" onclick="">

                &nbsp;

            </a>
            <div id="auto-download-modal" class="sr-modal ">
                <div class="sr-modal__content sr-modal__content--center ">
                    <div class="sr-modal__body ">

                        <div class="p-h-10 p-v-10">
                            <h3>Download PDF</h3>
                            <hr>
                            <div class="m-v-10 text-center">
                                Your requested download is ready!<br>
                                Click
                                <a class="pointer" data-source="in_content" data-action="start-download">
                                    here
                                </a>
                                to download.
                            </div>
                        </div>

                    </div>
                </div>
            </div>

        </div>
    </div>
</div> -->

<section class="ibpage-article-header" id="raid-levels-explained">
    <h3>4. What is RAID structure in OS? What are the different levels of RAID configuration? </h3>
    <article class="ibpage-article">
        <p>RAID (Redundant Arrays of Independent Disks) is a method used to store data on Multiple hard disks therefore
            it is considered as data storage virtualization technology that combines multiple hard disks. It simply
            balances data protection, system performance, storage space, etc. It is used to improve the overall
            performance and reliability of data storage. It also increases the storage capacity of the system and its
            main purpose is to achieve data redundancy to reduce data loss.&nbsp;<br><br><strong><u>Different levels of
                    RAID</u></strong><br><br>Nowadays, RAID is available in various schemes or RAID level as given
            below:</p>
        <!-- <figure class="image image_resized" style="width:50%;"><img
                data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/139/original/RAID_Level.png?1615545501"
                class=""
                src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/139/original/RAID_Level.png?1615545501">
        </figure> -->
        <ul>
            <li>RAID 0 - Non-redundant striping: This level is used to increase the performance of the server.</li>
            <li>RAID 1 - Mirroring and duplexing: This level is also known as disk mirroring and is considered the
                simplest way to implement fault tolerance.</li>
            <li>RAID 2 - Memory-style error-correcting codes: This level generally uses dedicated hamming code parity
                I.e., a liner form of error correction code.</li>
            <li>RAID 3 - Bit-interleaved Parity: This level requires a dedicated parity drive to store parity
                information.</li>
            <li>RAID 4 - Block-interleaved Parity: This level is similar to RAID 5 but the only difference is that this
                level confines all parity data to a single drive.</li>
            <li>RAID 5 - Block-interleaved distributed Parity: This level provides far better performance than disk
                mirroring and fault tolerance.</li>
            <li>RAID 6 - P+Q Redundancy: This level generally provides fault tolerance for two drive failures.</li>
        </ul>
    </article>
</section>
<section class="ibpage-article-header" id="what-is-gui">
    <h3>5. What is GUI?</h3>
    <article class="ibpage-article">
        <p>GUI (Graphical User Interface) is basically a type of user interface that allows users to use graphics to
            interact with OS. GUI is created because it is more user-friendly, less complex, and easier to understand
            rather than a command-line interface. Its main goal is to increase efficiency and ease of use. Instead of
            having to memorize commands, users can just click on a button to simply execute the procedure. Examples of
            GUI include Microsoft Windows, macOS, Apple’s iOS, etc.</p>
    </article>
</section>
<section class="ibpage-article-header" id="ipc-technique-pipes">
    <h3>6. What is a Pipe and when it is used?</h3>
    <article class="ibpage-article">
        <p>The pipe is generally a connection among two or more processes that are interrelated to each other. It is a
            mechanism that is used for inter-process communication using message passing. &nbsp;One can easily send
            information such as the output of one program process to another program process using a pipe. It can be
            used when two processes want to communicate one-way i.e., inter-process communication (IPC).</p>
    </article>
</section>
<section class="ibpage-article-header" id="os-semaphore-operations">
    <h3>7. What are the different kinds of operations that are possible on semaphore?</h3>
    <article class="ibpage-article">
        <p>There are basically two atomic operations that are possible:</p>
        <ul>
            <li>Wait()</li>
            <li>Signal()</li>
        </ul>
    </article>
</section>
<section class="ibpage-article-header" id="bootstrap-program-os">
    <h3>8. What is a bootstrap program in OS?</h3>
    <article class="ibpage-article">
        <p>It is generally a program that initializes OS during startup i.e., first code that is executed whenever
            computer system startups. OS is loaded through a bootstrapping process or program commonly known as booting.
            Overall OS only depends on the bootstrap program to perform and work correctly. It is fully stored in boot
            blocks at a fixed location on the disk. It also locates the kernel and loads it into the main memory after
            which the program starts its execution.</p>
        <!-- <figure class="image image_resized" style="width:50%;"><img
                data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/140/original/boostrap_program_in_os.png?1615546151"
                class=""
                src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/140/original/boostrap_program_in_os.png?1615546151">
        </figure> -->
    </article>
</section>
<section class="ibpage-article-header" id="demand-paging">
    <h3>9. Explain demand paging?</h3>
    <article class="ibpage-article">
        <p>Demand paging is a method that loads pages into memory on demand. This method is mostly used in virtual
            memory. In this, a page is only brought into memory when a location on that particular page is referenced
            during execution. The following steps are generally followed:</p>
        <ul>
            <li>Attempt to access the page.</li>
            <li>If the page is valid (in memory) then continue processing instructions as normal.</li>
            <li>If a page is invalid then a <strong>page-fault trap</strong> occurs.</li>
            <li>Check if the memory reference is a valid reference to a location on secondary memory. If not, the
                process is terminated (<strong>illegal memory access</strong>). Otherwise, we have to <strong>page
                    in</strong> the required page.</li>
            <li>Schedule disk operation to read the desired page into main memory.</li>
            <li>Restart the instruction that was interrupted by the operating system trap.</li>
        </ul>
    </article>
</section>
<section class="ibpage-article-header" id="real-time-operating-system">
    <h3>10. What do you mean by RTOS?</h3>
    <article class="ibpage-article">
        <p>Real Time Operating System (RTOS) is an operating system that is used for real-time applications i.e., for
            those applications where data processing should be done in a fixed and small measure of time. It performs
            much better on tasks that are needed to be executed within a short time. It also takes care of execution,
            monitoring, and all-controlling processes. It also occupies less memory and consumes fewer resources.&nbsp;
        </p>
        <p><strong>Types of RTOS:</strong></p>
        <ul>
            <li>Hard Real-Time</li>
            <li>Firm Real-Time</li>
            <li>Soft Real-Time</li>
        </ul>
        <!-- <figure class="image image_resized" style="width:50%;"><img
                data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/141/original/RTOS.png?1615546454"
                class=""
                src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/141/original/RTOS.png?1615546454">
        </figure> -->
        <p>RTOS is used in Air traffic control systems, Anti-lock Brake Systems, and Heart pacemakers.</p>
    </article>
</section>
<section class="ibpage-article-header" id="process-synchronization">
    <h3>11. What do you mean by process synchronization?</h3>
    <article class="ibpage-article">
        <p>Process synchronization is basically a way to coordinate processes that use shared resources or data. It is
            very much essential to ensure synchronized execution of cooperating processes so that will maintain data
            consistency. Its main purpose is to share resources without any interference using mutual exclusion. There
            are two types of process synchronization:</p>
        <ul>
            <li>Independent Process</li>
            <li>Cooperative Process</li>
        </ul>
    </article>
</section>
<section class="ibpage-article-header" id="inter-process-communication-ipc">
    <h3>12. What is IPC? What are the different IPC mechanisms?</h3>
    <article class="ibpage-article">
        <p>IPC (Interprocess Communication) is a mechanism that requires the use of resources like a memory that is
            shared between processes or threads. With IPC, OS allows different processes to communicate with each other.
            It is simply used for exchanging data between multiple threads in one or more programs or processes. In this
            mechanism, different processes can communicate with each other with the approval of the OS.</p>
        <p><strong>Different IPC Mechanisms:</strong></p>
        <ul>
            <li>Pipes</li>
            <li>Message Queuing</li>
            <li>Semaphores</li>
            <li>Socket</li>
            <li>Shared Memory</li>
            <li>Signals</li>
        </ul>
    </article>
</section>
<section class="ibpage-article-header" id="difference-between-primary-and-secondary-memory">
    <h3>13. What is different between main memory and secondary memory. </h3>
    <article class="ibpage-article">
        <p><strong>Main memory:</strong> Main memory in a computer is RAM (Random Access Memory). It is also known as
            primary memory or read-write memory or internal memory. The programs and data that the CPU requires during
            the execution of a program are stored in this memory.<br><strong>Secondary memory:</strong> Secondary memory
            in a computer are storage devices that can store data and programs. It is also known as external memory or
            additional memory or backup memory or auxiliary memory. Such storage devices are capable of storing
            high-volume data. Storage devices can be hard drives, USB flash drives, CDs, etc.&nbsp;</p>
        <figure class="table">
            <table>
                <thead>
                    <tr>
                        <th>Primary Memory</th>
                        <th>Secondary Memory</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Data can be directly accessed by the processing unit.</td>
                        <td>Firstly, data is transferred to primary memory and after then routed to the processing unit.
                        </td>
                    </tr>
                    <tr>
                        <td>It can be both volatile and non-volatile in nature.</td>
                        <td>It is non-volatile in nature.</td>
                    </tr>
                    <tr>
                        <td>It is more costly than secondary memory.</td>
                        <td>It is more cost-effective or less costly than primary memory.</td>
                    </tr>
                    <tr>
                        <td>It is temporary because data is stored temporarily.</td>
                        <td>It is permanent because data is stored permanently.</td>
                    </tr>
                    <tr>
                        <td>In this memory, data can be lost whenever there is a power failure.</td>
                        <td>In this memory, data is stored permanently and therefore cannot be lost even in case of
                            power failure.</td>
                    </tr>
                    <tr>
                        <td>It is much faster than secondary memory and saves data that is currently used by the
                            computer.</td>
                        <td>It is slower as compared to primary memory and saves different kinds of data in different
                            formats.</td>
                    </tr>
                    <tr>
                        <td>It can be accessed by data.</td>
                        <td>It can be accessed by I/O channels.</td>
                    </tr>
                </tbody>
            </table>
        </figure>
    </article>
</section>
<section class="ibpage-article-header" id="overlays-in-operating-system">
    <h3>14. What do you mean by overlays in OS?</h3>
    <article class="ibpage-article">
        <p>Overlays is basically a programming method that divides processes into pieces so that instructions that are
            important and need can be saved in memory. It does not need any type of support from the OS. It can run
            programs that are bigger in size than physical memory by only keeping only important data and instructions
            that can be needed at any given time.&nbsp;</p>
    </article>
</section>
<section class="ibpage-article-header" id="top-operating-system-examples">
    <h3>15. Write top 10 examples of OS?</h3>
    <article class="ibpage-article">
        <p>Some of the top OS’s that are used mostly are given below:</p>
        <ul>
            <li>MS-Windows</li>
            <li>Ubuntu</li>
            <li>Mac OS</li>
            <li>Fedora</li>
            <li>Solaris</li>
            <li>Free BSD</li>
            <li>Chrome OS</li>
            <li>CentOS</li>
            <li>Debian</li>
            <li>Android</li>
        </ul>
    </article>
</section>

</div>
<div id="os-intermediate-questions">
    <h2>Intermediate OS Interview Questions</h2>

    <section class="ibpage-article-header" id="os-virtual-memory">
        <h3>16. What is virtual memory?</h3>
        <article class="ibpage-article">
            <p>It is a memory management technique feature of OS that creates the illusion to users of a very large
                (main) memory. It is simply space where a greater number of programs can be stored by themselves in the
                form of pages. It enables us to increase the use of physical memory by using a disk and also allows us
                to have memory protection. It can be managed in two common ways by OS i.e., paging and segmentation. It
                acts as temporary storage that can be used along with RAM for computer processes.&nbsp;</p>
            <!-- <figure class="image image_resized" style="width:50%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/142/original/virtual_memory.png?1615547959"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/142/original/virtual_memory.png?1615547959">
            </figure> -->
        </article>
    </section>
    <section class="ibpage-article-header" id="thread-in-operating-system">
        <h3>17. What is thread in OS?</h3>
        <article class="ibpage-article">
            <p>Thread is a path of execution that is composed of a program counter, thread id, stack, and set of
                registers within the process. It is a basic unit of CPU utilization that makes communication more
                effective and efficient, enables utilization of multiprocessor architectures to a greater scale and
                greater efficiency, and reduces the time required in context switching. It simply provides a way to
                improve and increase the performance of applications through parallelism. Threads are sometimes called
                <strong>lightweight processes</strong> because they have their own stack but can access shared
                data.&nbsp;<br><br>Multiple threads running in a process share: Address space, Heap, Static data, Code
                segments, File descriptors, Global variables, Child processes, Pending alarms, Signals, and signal
                handlers.&nbsp;<br><br>Each thread has its own: Program counter, Registers, Stack, and State.</p>
            <!-- <figure class="image image_resized" style="width:50%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/143/original/thread_in_os.png?1615548056"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/143/original/thread_in_os.png?1615548056">
            </figure> -->
        </article>
    </section>
    <section class="ibpage-article-header" id="operating-system-processes">
        <h3>18. What is a process? What are the different states of a process?</h3>
        <article class="ibpage-article">
            <p>The process is basically a program that is currently under execution. The main function of an OS is to
                manage and handle all of these processes. When a program is loaded into the memory and it becomes a
                process, it can be divided into four sections ─ stack, heap, text, and data. There are two types of
                processes:</p>
            <ol>
                <li>Operating System Processes</li>
                <li>User Processes</li>
            </ol>
            <!-- <figure class="image image_resized" style="width:75%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/144/original/states_of_process.png?1615548548"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/144/original/states_of_process.png?1615548548">
            </figure> -->
            <p><strong>States of Process:</strong><br><br>Different states of the process through which process goes are
                given below:</p>
            <ul>
                <li>
                    <strong>New State</strong>: In this state, a process is just created.
                </li>
                <li>
                    <strong>Running: </strong>In this state, the CPU starts working on the process’s instructions.
                </li>
                <li>
                    <strong>Waiting:</strong> In this state, the process cannot run because it just waits for some event
                    to occur
                </li>
                <li>
                    <strong>Ready:</strong> In this state, the process has all resources available that are required to
                    run but it waits to get assigned to a processor because CPUs are not working currently on
                    instructions passed by the process.
                </li>
                <li>
                    <strong>Terminate:</strong> In this state, the process is completed I.e., the process has finished
                    execution.
                </li>
            </ul>
        </article>
    </section>
    <section class="ibpage-article-header" id="first-come-first-served-fcfs">
        <h3>19. What do you mean by FCFS?</h3>
        <article class="ibpage-article">
            <p><strong>FCFS</strong> (First Come First Serve) is a type of OS scheduling algorithm that executes
                processes in the same order in which processes arrive. In simple words, the process that arrives first
                will be executed first. It is non-preemptive in nature. FCFS scheduling may cause the problem of
                starvation if the burst time of the first process is the longest among all the jobs. Burst time here
                means the time that is required in milliseconds by the process for its execution. It is also considered
                the easiest and simplest OS scheduling algorithm as compared to others. Implementation of FCFS is
                generally managed with help of the FIFO (First In First Out) queue.&nbsp;</p>
        </article>
    </section>
    <section class="ibpage-article-header" id="reentrant-function">
        <h3>20. What is Reentrancy?</h3>
        <article class="ibpage-article">
            <p>Reentrant is simply a function in which various clients can use and shares a single copy of a program
                during a similar period. This concept is generally associated with OS code and does not deal with
                concurrency. It has two major functions:</p>
            <ul>
                <li>Program code cannot change or modify itself.</li>
                <li>Local data for every client process needs to be stored in different disks.</li>
            </ul>
        </article>
    </section>
    <section class="ibpage-article-header" id="os-process-scheduling-algorithms">
        <h3>21. What is a Scheduling Algorithm? Name different types of scheduling algorithms.</h3>
        <article class="ibpage-article">
            <p>A scheduling algorithm is a process that is used to improve efficiency by utilizing maximum CPU and
                providing minimum waiting time to tasks. It simply deals with the problem of deciding which of
                outstanding requests is to be allocated resources. Its main aim is to reduce resource starvation and to
                ensure fairness amongst parties that are utilizing the resources. In simple words, it is used to
                allocate resources among various competing tasks.&nbsp;<br><br><strong><u>Types of Scheduling
                        Algorithm</u></strong><br><br>There are different types of scheduling algorithms as given below:
            </p>
            <!-- <figure class="image image_resized" style="width:75%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/145/original/scheduling-algorithm-os.png?1615549046"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/145/original/scheduling-algorithm-os.png?1615549046">
            </figure> -->
        </article>
    </section>
    <section class="ibpage-article-header" id="difference-between-paging-and-segmentation">
        <h3>22. What is the difference between paging and segmentation?</h3>
        <article class="ibpage-article">
            <p><strong>Paging:</strong> It is generally a memory management technique that allows OS to retrieve
                processes from secondary storage into main memory. It is a non-contiguous allocation technique that
                divides each process in the form of pages.&nbsp;<br><strong>Segmentation: </strong>It is generally a
                memory management technique that divides processes into modules and parts of different sizes. These
                parts and modules are known as segments that can be allocated to process.&nbsp;</p>
            <figure class="table">
                <table>
                    <thead>
                        <tr>
                            <th>Paging</th>
                            <th>Segmentation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>It is invisible to a programmer.</td>
                            <td>It is visible to a programmer.</td>
                        </tr>
                        <tr>
                            <td>In this, the size of pages is fixed.</td>
                            <td>In this, the size of segments is not fixed.</td>
                        </tr>
                        <tr>
                            <td>Procedures and data cannot be separated in paging.</td>
                            <td>Procedures and data can be separated in segmentation.</td>
                        </tr>
                        <tr>
                            <td>It allows a cumulative total of virtual address spaces to cross physical main memory.
                            </td>
                            <td>It allows all programs, data, and codes to break up into independent address spaces.
                            </td>
                        </tr>
                        <tr>
                            <td>It is mostly available on CPUs and MMU chips.</td>
                            <td>It is mostly available on Windows servers that may support backward compatibility, while
                                Linux has limited support.</td>
                        </tr>
                        <tr>
                            <td>It is faster for memory access as compared to segmentation.</td>
                            <td>It is slower as compared to paging.</td>
                        </tr>
                        <tr>
                            <td>In this, OS needs to maintain a free frame.</td>
                            <td>In this, OS needs to maintain a list of holes in the main memory.</td>
                        </tr>
                        <tr>
                            <td>In paging, the type of fragmentation is internal.</td>
                            <td>In segmentation, the type of fragmentation is external.</td>
                        </tr>
                        <tr>
                            <td>The size of the page is determined by available memory.</td>
                            <td>The size of the page is determined by the user.</td>
                        </tr>
                    </tbody>
                </table>
            </figure>
        </article>
    </section>
    <section class="ibpage-article-header" id="thrashing-in-os">
        <h3>23. What is thrashing in OS?</h3>
        <article class="ibpage-article">
            <p>It is generally a situation where the CPU performs less productive work and more swapping or paging work.
                It spends more time swapping or paging activities rather than its execution. By evaluating the level of
                CPU utilization, a system can detect thrashing. It occurs when the process does not have enough pages
                due to which the page-fault rate is increased. It inhibits much application-level processing that causes
                computer performance to degrade or collapse.&nbsp;</p>
        </article>
    </section>
    <section class="ibpage-article-header" id="multiprogramming">
        <h3>24. What is the main objective of multiprogramming?</h3>
        <article class="ibpage-article">
            <p>It refers to the ability to execute or perform more than one program on a single processor machine. This
                technique was introduced to overcome the problem of underutilization of CPU and main memory. In simple
                words, it is the coordination of execution of various programs simultaneously on a single processor
                (CPU). The main objective of multiprogramming is to have at least some processes running at all times.
                It simply improves the utilization of the CPU as it organizes many jobs where the CPU always has one to
                execute.&nbsp;</p>
            <!-- <figure class="image image_resized" style="width:75%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/146/original/multiprogramming.png?1615549850"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/146/original/multiprogramming.png?1615549850">
            </figure> -->
        </article>
    </section>
    <section class="ibpage-article-header" id="what-is-asymmetric-clustering">
        <h3>25. What do you mean by asymmetric clustering?</h3>
        <article class="ibpage-article">
            <p>Asymmetric Clustering is generally a system in which one of the nodes among all nodes is in hot standby
                mode whereas the rest of all nodes run different applications. It simply uses whole or entire hardware
                resources therefore it is considered a more reliable system as compared to others.&nbsp;</p>
            <!-- <figure class="image image_resized" style="width:75%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/147/original/asymmetric_cluttering.png?1615550008"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/147/original/asymmetric_cluttering.png?1615550008">
            </figure> -->
        </article>
    </section>
    <section class="ibpage-article-header" id="difference-between-multitasking-and-multiprocessing">
        <h3>26. What is the difference between multitasking and multiprocessing OS?</h3>
        <article class="ibpage-article">
            <p><strong>Multitasking: </strong>It is a system that allows more efficient use of computer hardware. This
                system works on more than one task at one time by rapidly switching between various tasks. These systems
                are also known as time-sharing systems.&nbsp;</p>
            <!-- <figure class="image image_resized" style="width:50%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/148/original/multitasking-os.png?1615550131"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/148/original/multitasking-os.png?1615550131">
            </figure> -->
            <p><strong>Multiprocessing: </strong>It is a system that allows multiple or various processors in a computer
                to process two or more different portions of the same program simultaneously. It is used to complete
                more work in a shorter period of time.&nbsp;<br>&nbsp;</p>
            <!-- <figure class="image image_resized" style="width:50%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/149/original/multiprocessing.png?1615550179"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/149/original/multiprocessing.png?1615550179">
            </figure> -->
            <figure class="table">
                <table>
                    <thead>
                        <tr>
                            <th>Multitasking</th>
                            <th>Multiprocessing</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>It performs more than one task at a time using a single processor.</td>
                            <td>It performs more than one task at a time using multiple processors.</td>
                        </tr>
                        <tr>
                            <td>In this, the number of CPUs is only one.</td>
                            <td>In this, the number of CPUs is more than one.</td>
                        </tr>
                        <tr>
                            <td>It is more economical.</td>
                            <td>It is less economical.</td>
                        </tr>
                        <tr>
                            <td>It is less efficient than multiprocessing.</td>
                            <td>It is more efficient than multitasking.</td>
                        </tr>
                        <tr>
                            <td>It allows fast switching among various tasks.</td>
                            <td>It allows smooth processing of multiple tasks at once.</td>
                        </tr>
                        <tr>
                            <td>It requires more time to execute tasks as compared to multiprocessing.</td>
                            <td>It requires less time for job processing as compared to multitasking.</td>
                        </tr>
                    </tbody>
                </table>
            </figure>
        </article>
    </section>
    <section class="ibpage-article-header" id="socket-in-os">
        <h3>27. What do you mean by Sockets in OS?</h3>
        <article class="ibpage-article">
            <p>The socket in OS is generally referred to as an endpoint for IPC (Interprocess Communication). Here, the
                endpoint is referred to as a combination of an IP address and port number. &nbsp;Sockets are used to
                make it easy for <a href="https://www.scaler.com/courses/full-stack-developer/" target="_blank"
                    rel="noopener noreferrer nofollow">software developers</a> to create network-enabled programs. It
                also allows communication or exchange of information between two different processes on the same or
                different machines. It is mostly used in client-server-based systems.&nbsp;<br><br><strong><u>Types of
                        Sockets</u></strong><br><br>There are basically four types of sockets as given below:</p>
            <ul>
                <li>Stream Sockets</li>
                <li>Datagram Sockets</li>
                <li>Sequenced Packet Sockets</li>
                <li>Raw Sockets</li>
            </ul>
        </article>
    </section>
    <section class="ibpage-article-header" id=" zombie-process-os">
        <h3>28. Explain zombie process?</h3>
        <article class="ibpage-article">
            <p>Zombie process, referred to as a defunct process, is basically a process that is terminated or completed
                but the whole process control block is not cleaned up from the main memory because it still has an entry
                in the process table to report to its parent process. It does not consume any of the resources and is
                dead, but it still exists. It also shows that resources are held by process and are not free.</p>
        </article>
    </section>
    <section class="ibpage-article-header" id="cascading-termination-os">
        <h3>29. What do you mean by cascading termination?</h3>
        <article class="ibpage-article">
            <p>Cascading termination is a process termination in which if the parent process is exiting or terminating
                then the children process will also get terminated. It does not allow the child to continue processing
                as its parent process terminates. It is generally initiated by OS.</p>
        </article>
    </section>
    <section class="ibpage-article-header" id="starvation-and-aging-in-operating-systems">
        <h3>30. What is starvation and aging in OS?</h3>
        <article class="ibpage-article">
            <p>When we use Priority Scheduling or Shortest Job First Scheduling, Starvation can happen, This algorithm
                is mostly used in CPU schedulers</p>
            <p><strong><u>Starvation: </u></strong>It is generally a problem that usually occurs when a process has not
                been able to get the required resources it needs for progress with its execution for a long period of
                time. In this condition, low priority processes get blocked and only high priority processes proceed
                towards completion because of which low priority processes suffer from lack of
                resources.&nbsp;<br><br><strong><u>Aging:</u></strong> It is a technique that is used to overcome the
                situation or problem of starvation. It simply increases the priority of processes that wait in the
                system for resources for a long period of time. It is considered the best technique to resolve the
                problem of starvation as it adds an aging factor to the priority of each and every request by various
                processes for resources. It also ensures that low-level queue jobs or processes complete their
                execution.&nbsp;</p>
        </article>
    </section>

</div>
<div id="os-advanced-questions">
    <h2>Advanced OS Interview Questions</h2>

    <section class="ibpage-article-header" id="semaphore-and-its-types">
        <h3>31. What do you mean by Semaphore in OS? Why is it used?</h3>
        <article class="ibpage-article">
            <p>Semaphore is a signaling mechanism. It only holds one positive integer value. It is simply used to solve
                the problem or issue of critical sections in the synchronization process by using two atomic operations
                i.e., wait() and signal().&nbsp;</p>
            <p><strong><u>Types of Semaphore</u></strong><br>There are usually two types of semaphores as given below:
            </p>
            <ul>
                <li>Binary Semaphore</li>
                <li>Counting Semaphore</li>
            </ul>
            <figure class="table">
                <table>
                    <thead>
                        <tr>
                            <th>Binary Semaphore</th>
                            <th>Mutex</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>It allows various process threads to get the finite instance of the resource until
                                resources are available.</td>
                            <td>It allows various process threads to get single shared resource only at a time.</td>
                        </tr>
                        <tr>
                            <td>Its functions are based upon signaling mechanisms.</td>
                            <td>Its functions are based upon a locking mechanism.</td>
                        </tr>
                        <tr>
                            <td>Binary semaphores are much faster as compared to Mutex.</td>
                            <td>Mutex is slower as compared to binary semaphores.</td>
                        </tr>
                        <tr>
                            <td>It is basically an integer.</td>
                            <td>It is basically an object.</td>
                        </tr>
                    </tbody>
                </table>
            </figure>
        </article>
    </section>
    <section class="ibpage-article-header" id="kernel-and-its-functions-os">
        <h3>32. What is Kernel and write its main functions?</h3>
        <article class="ibpage-article">
            <p>The kernel is basically a computer program usually considered as a central component or module of OS. It
                is responsible for handling, managing, and controlling all operations of computer systems and hardware.
                Whenever the system starts, the kernel is loaded first and remains in the main memory. It also acts as
                an interface between user applications and hardware.</p>
            <!-- <figure class="image image_resized" style="width:75%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/150/original/kernel-os.png?1615551314"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/150/original/kernel-os.png?1615551314">
            </figure> -->
            <p><strong>Functions of Kernel:</strong></p>
            <ul>
                <li>It is responsible for managing all computer resources such as CPU, memory, files, processes, etc.
                </li>
                <li>It facilitates or initiates the interaction between components of hardware and software.</li>
                <li>It manages RAM memory so that all running processes and programs can work effectively and
                    efficiently.</li>
                <li>It also controls and manages all primary tasks of the OS as well as manages access and use of
                    various peripherals connected to the computer.</li>
                <li>It schedules the work done by the CPU so that the work of each user is executed as efficiently as
                    possible.</li>
            </ul>
        </article>
    </section>
    <section class="ibpage-article-header" id="kernel-in-operating-system">
        <h3>33. What are different types of Kernel?</h3>
        <article class="ibpage-article">
            <p>There are basically five types of Kernels as given below:</p>
            <ul>
                <li>Monolithic Kernel</li>
                <li>MicroKernel</li>
                <li>Hybrid Kernel&nbsp;</li>
                <li>Nano Kernel</li>
                <li>Exo Kernel</li>
            </ul>
        </article>
    </section>
    <section class="ibpage-article-header" id="difference-between-microkernel-and-monolithic-kernel">
        <h3>34. Write difference between micro kernel and monolithic kernel?</h3>
        <article class="ibpage-article">
            <p><strong>MicroKernel</strong>: It is a minimal OS that executes only important functions of OS. It only
                contains a near-minimum number of features and functions that are required to implement
                OS.&nbsp;<br><u>Example:</u> QNX, Mac OS X, K42, etc.<br><br><strong>Monolithic Kernel:</strong> It is
                an OS architecture that supports all basic features of computer components such as resource management,
                memory, file, etc.&nbsp;<br><u>Example:</u> Solaris, DOS, OpenVMS, Linux, etc.&nbsp;</p>
            <!-- <figure class="image image_resized" style="width:75%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/151/original/monolithic_and_microkernel.png?1615551565"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/151/original/monolithic_and_microkernel.png?1615551565">
            </figure> -->
            <figure class="table">
                <table>
                    <thead>
                        <tr>
                            <th>MicroKernel</th>
                            <th>Monolithic Kernel</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>In this software or program, kernel services and user services are present in different
                                address spaces.</td>
                            <td>In this software or program, kernel services and user services are usually present in
                                the same address space.</td>
                        </tr>
                        <tr>
                            <td>It is smaller in size as compared to the monolithic kernel.</td>
                            <td>It is larger in size as compared to a microkernel.</td>
                        </tr>
                        <tr>
                            <td>It is easily extendible as compared to a monolithic kernel.</td>
                            <td>It is hard to as extend as compared to a microkernel.</td>
                        </tr>
                        <tr>
                            <td>If a service crashes, it does affect on working of the microkernel.</td>
                            <td>If a service crashes, the whole system crashes in a monolithic kernel.</td>
                        </tr>
                        <tr>
                            <td>It uses message queues to achieve inter-process communication.</td>
                            <td>It uses signals and sockets to achieve inter-process communication.</td>
                        </tr>
                    </tbody>
                </table>
            </figure>
        </article>
    </section>
    <section class="ibpage-article-header" id="what-is-smp-symmetric-multi-processing">
        <h3>35. What is SMP (Symmetric Multiprocessing)?</h3>
        <article class="ibpage-article">
            <p>SMP is generally referred to as computer architecture in which the processing of programs is done by
                multiple processors that share a common OS and memory. SMP is very much required if you want to take
                advantage of multiprocessor hardware. It simply enables any processor to work on any of the tasks no
                matter where data or resources for that particular task are located in memory. These systems are more
                reliable than single-processor systems.&nbsp;</p>
        </article>
    </section>
    <section class="ibpage-article-header" id="what-is-time-sharing system">
        <h3>36. What is a time-sharing system?</h3>
        <article class="ibpage-article">
            <p>It is a system that allows more than one user to access the resources of a particular system in many
                locations. In simple words, it performs multiple tasks on a single processor or CPU. As the name
                suggests, it means to share time into multiple slots in several processes. It also allows different
                users from different locations to use a particular computer system at the same time therefore it is
                considered one of the important types of OS.</p>
            <!-- <figure class="image image_resized" style="width:50%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/152/original/multiprocessing.png?1615552971"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/152/original/multiprocessing.png?1615552971">
            </figure> -->
        </article>
    </section>
    <section class="ibpage-article-header" id="what-is-context-switching-in-operating-system">
        <h3>37. What is Context Switching?</h3>
        <article class="ibpage-article">
            <p>Context switching is basically a process of saving the context of one process and loading the context of
                another process. It is one of the cost-effective and time-saving measures executed by CPU the because it
                allows multiple processes to share a single CPU. Therefore, it is considered an important part of a
                modern OS. This technique is used by OS to switch a process from one state to another i.e., from running
                state to ready state. It also allows a single CPU to handle and control various different processes or
                threads without even the need for additional resources.</p>
        </article>
    </section>
    <section class="ibpage-article-header" id="kernel-vs-os">
        <h3>38. What is difference between Kernel and OS?</h3>
        <article class="ibpage-article">
            <p><strong>Kernel:</strong> Kernel is a system program that controls all programs running on the computer.
                The kernel is basically a bridge between the software and hardware of the
                system.<br><br><strong>Operating System:</strong> Operating system is a system program that runs on the
                computer to provide an interface to the computer user so that they can easily operate on the computer.
            </p>
            <!-- <figure class="image image_resized" style="width:50%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/153/original/kernel_oS.png?1615553527"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/153/original/kernel_oS.png?1615553527">
            </figure> -->
            <figure class="table">
                <table>
                    <thead>
                        <tr>
                            <th>Kernel</th>
                            <th>OS</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>It is considered a central component of OS</td>
                            <td>It is considered system software.</td>
                        </tr>
                        <tr>
                            <td>It is generally responsible for converting user commands into machine-level commands.
                            </td>
                            <td>It is generally responsible for managing the resources of system.</td>
                        </tr>
                        <tr>
                            <td>It simply acts as an interface between hardware and applications.</td>
                            <td>It simply acts as an interface between hardware and user.</td>
                        </tr>
                        <tr>
                            <td>It also performs functions like process management, file management, device management,
                                I/O communication, etc.</td>
                            <td>It also performs functions like providing security to data and files in the the system,
                                providing access controls to users, maintaining the system privacy, etc.</td>
                        </tr>
                        <tr>
                            <td>Its type includes Microkernel, Monolithic kernel, etc.</td>
                            <td>Its type includes Single and Multiprogramming batch systems, Distributed OS, Real-time
                                OS.</td>
                        </tr>
                    </tbody>
                </table>
            </figure>
        </article>
    </section>
    <section class="ibpage-article-header" id="difference-between-process-and-thread">
        <h3>39. What is difference between process and thread?</h3>
        <article class="ibpage-article">
            <p><strong>Process:</strong> It is basically a program that is currently under execution by one or more
                threads. It is a very important part of the modern-day OS.<br><br><strong>Thread:</strong> It is a path
                of execution that is composed of the program counter, thread id, stack, and set of registers within the
                process.</p>
            <!-- <figure class="image image_resized" style="width:50%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/154/original/Process_and_Thread.png?1615553801"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/154/original/Process_and_Thread.png?1615553801">
            </figure> -->
            <figure class="table">
                <table>
                    <thead>
                        <tr>
                            <th>Process</th>
                            <th>Thread</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>It is a computer program that is under execution.</td>
                            <td>It is the component or entity of the process that is the smallest execution unit.</td>
                        </tr>
                        <tr>
                            <td>These are heavy-weight operators.</td>
                            <td>These are lightweight operators.</td>
                        </tr>
                        <tr>
                            <td>It has its own memory space.</td>
                            <td>It uses the memory of the process they belong to.</td>
                        </tr>
                        <tr>
                            <td>It is more difficult to create a process as compared to creating a thread.</td>
                            <td>It is easier to create a thread as compared to creating a process.</td>
                        </tr>
                        <tr>
                            <td>It requires more resources as compared to thread.</td>
                            <td>It requires fewer resources as compared to processes.</td>
                        </tr>
                        <tr>
                            <td>It takes more time to create and terminate a process as compared to a thread.</td>
                            <td>It takes less time to create and terminate a thread as compared to a process.</td>
                        </tr>
                        <tr>
                            <td>It usually run-in separate memory space.</td>
                            <td>It usually run-in shared memory space.</td>
                        </tr>
                        <tr>
                            <td>It does not share data.</td>
                            <td>It shares data with each other.</td>
                        </tr>
                        <tr>
                            <td>It can be divided into multiple threads.</td>
                            <td>It can’t be further subdivided.</td>
                        </tr>
                    </tbody>
                </table>
            </figure>
        </article>
    </section>
    <section class="ibpage-article-header" id="os-processes">
        <h3>40. What are various sections of the process?</h3>
        <article class="ibpage-article">
            <p>There are basically four sections in the process as given below:</p>
            <!-- <figure class="image image_resized" style="width:50%;"><img
                    data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/155/original/OS_Process.png?1615554162"
                    class=""
                    src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/155/original/OS_Process.png?1615554162">
            </figure> -->
            <ul>
                <li>
                    <strong>Stack:</strong> It is used for local variables and returns addresses.&nbsp;
                </li>
                <li>
                    <strong>Heap:</strong> It is used for dynamic memory allocation.
                </li>
                <li>
                    <strong>Data</strong>: It stores global and static variables.
                </li>
                <li>
                    <strong>Code or text:</strong> It comprises compiled program code.
                </li>
            </ul>
        </article>
    </section>
    <section class="ibpage-article-header" id="what-is-deadlock-and-what-are-its-four-necessary-conditions">
        <h3>41. What is a deadlock in OS? What are the necessary conditions for a deadlock?</h3>
        <article class="ibpage-article">
            <p>Deadlock is generally a situation where a set of processes are blocked as each process is holding
                resources and waits to acquire resources held by another process. In this situation, two or more
                processes simply try to execute simultaneously and wait for each to finish their execution because they
                are dependent on each other. We can see a hand problem in our system whenever a deadlock occurs in a
                program. It is one of the common problems you can see in
                multiprocessing.&nbsp;<br><br><strong><u>Necessary Conditions for Deadlock</u></strong><br><br>There are
                basically four necessary conditions for deadlock as given below:</p>
            <ul>
                <li>Mutual Exclusion</li>
                <li>Hold and Wait</li>
                <li>No Pre-emption</li>
                <li>Circular Wait or Resource Wait</li>
            </ul>
        </article>
    </section>
    <section class="ibpage-article-header" id="os-beladys-anamoly">
        <h3>42. What do you mean by Belady’s Anomaly?</h3>
        <article class="ibpage-article">
            <p>In the Operating System, process data is loaded in fixed-sized chunks and each chunk is referred to as a
                page. The processor loads these pages in the fixed-sized chunks of memory called frames. Belady’s
                Anomaly is a phenomenon in which if we increase the number of frames in memory, then the number of page
                faults also increases. It is generally experienced when we use FIFO (First in First out) page
                replacement algorithm.&nbsp;</p>
        </article>
    </section>
    <section class="ibpage-article-header" id="spooling-in-os">
        <h3>43. What is spooling in OS?</h3>
        <article class="ibpage-article">
            <p>Spooling simply stands for Simultaneous peripheral operations online. It is referred to as putting data
                of various I/O jobs in a buffer. Here, buffer means a special area in memory or hard disk that can be
                accessible to an I/O device. It is used for mediation between a computer application and a slow
                peripheral. It is very useful and important because devices access or acquire data at different rates.
                This operation also uses disk as a very large buffer and is capable of overlapping I/O operations for
                one task with processor operations for another task.</p>
        </article>
    </section>

</div>

</section>
<!-- Artilce Block END -->
<!-- Problem Block START -->
